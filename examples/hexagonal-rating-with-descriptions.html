<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>VCSCI Hexagonal Rating - Interfaz Biling칲e</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Lexend:wght@300;400;500;600;700&display=swap" rel="stylesheet">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Lexend', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: #fafbfc;
      padding: 30px 20px;
      line-height: 1.6;
      font-weight: 400;
      color: #2c3e50;
    }

    .container {
      max-width: 1400px;
      margin: 0 auto;
    }

    h1 {
      text-align: center;
      color: #2c3e50;
      margin-bottom: 8px;
      font-size: 28px;
    }

    .subtitle {
      text-align: center;
      color: #7f8c8d;
      margin-bottom: 35px;
      font-size: 14px;
    }

    .demo-wrapper {
      display: grid;
      grid-template-columns: 350px 1fr 450px;
      gap: 25px;
      margin-bottom: 25px;
    }

    /* Rating sliders */
    .ratings-section h2 {
      font-size: 16px;
      color: #34495e;
      margin-bottom: 20px;
      font-weight: 600;
    }

    .dimension-group {
      margin-bottom: 22px;
    }

    .dimension-label {
      display: block;
      font-weight: 600;
      color: #2c3e50;
      margin-bottom: 8px;
      font-size: 13px;
    }

    .slider-container {
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .slider {
      flex: 1;
      height: 6px;
      border-radius: 3px;
      outline: none;
      -webkit-appearance: none;
      background: #e1e8ed;
    }

    .slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: #3498db;
      cursor: pointer;
      box-shadow: 0 2px 4px rgba(0,0,0,0.15);
    }

    .slider::-moz-range-thumb {
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: #3498db;
      cursor: pointer;
      border: none;
      box-shadow: 0 2px 4px rgba(0,0,0,0.15);
    }

    .score-display {
      min-width: 35px;
      font-weight: 700;
      color: #2c3e50;
      font-size: 15px;
      text-align: center;
    }

    /* Hexagon visualization */
    .viz-section h2 {
      font-size: 16px;
      color: #34495e;
      margin-bottom: 15px;
      font-weight: 600;
      text-align: center;
    }

    #hexagonChart {
      display: block;
      margin: 0 auto 20px auto;
    }

    .vcsci-score {
      text-align: center;
      padding: 20px;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      border-radius: 8px;
    }

    .vcsci-score-value {
      font-size: 42px;
      font-weight: 700;
      margin-bottom: 5px;
    }

    .vcsci-score-label {
      font-size: 16px;
      opacity: 0.95;
      font-weight: 500;
    }

    /* Description panel */
    .description-section h2 {
      font-size: 16px;
      color: #34495e;
      margin-bottom: 15px;
      font-weight: 600;
    }

    .description-content {
      min-height: 380px;
    }

    .current-dimension {
      background: #f0f3f7;
      padding: 15px;
      border-radius: 6px;
      margin-bottom: 15px;
    }

    .current-dimension h3 {
      color: #2c3e50;
      font-size: 15px;
      margin-bottom: 6px;
      font-weight: 600;
    }

    .current-dimension .score-label {
      color: #5a6c7d;
      font-size: 13px;
      font-weight: 600;
      margin-bottom: 8px;
      display: block;
    }

    .dimension-definition {
      color: #7f8c8d;
      font-size: 12px;
      line-height: 1.5;
      font-style: italic;
      margin-top: 8px;
    }

    .description-text {
      color: #2c3e50;
      font-size: 14px;
      line-height: 1.75;
      text-align: left;
    }

    .no-selection {
      color: #95a5a6;
      font-style: italic;
      text-align: center;
      padding: 60px 20px;
    }

    /* Compiled evaluation */
    .compiled-section {
      margin-top: 20px;
    }

    .compiled-section h2 {
      font-size: 16px;
      color: #34495e;
      margin-bottom: 15px;
      font-weight: 600;
    }

    .compiled-evaluation {
      margin-top: 15px;
    }

    .evaluation-paragraph {
      margin-bottom: 12px;
      padding: 12px 15px;
      background: #f8f9fa;
      border-radius: 5px;
      border-left: 3px solid;
      font-size: 13px;
      line-height: 1.65;
      text-align: left;
    }

    .evaluation-paragraph strong {
      font-weight: 600;
    }

    .overall-summary {
      text-align: center;
      margin-bottom: 20px;
      padding: 15px;
      background: #f0f3f7;
      border-radius: 6px;
    }

    .overall-summary strong {
      font-size: 15px;
      display: block;
      margin-bottom: 6px;
    }

    .overall-summary em {
      font-size: 13px;
      color: #5a6c7d;
    }

    /* Export section */
    .export-section {
      margin-top: 25px;
      text-align: center;
    }

    .export-btn {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      border: none;
      padding: 14px 35px;
      border-radius: 6px;
      font-size: 15px;
      font-weight: 600;
      font-family: 'Lexend', sans-serif;
      cursor: pointer;
      box-shadow: 0 3px 12px rgba(102, 126, 234, 0.35);
      transition: all 0.3s ease;
    }

    .export-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 5px 18px rgba(102, 126, 234, 0.5);
    }

    .export-btn:active {
      transform: translateY(0);
    }

    .export-info {
      margin-top: 12px;
      font-size: 12px;
      color: #7f8c8d;
      font-style: italic;
    }

    /* Loading state */
    .loading {
      text-align: center;
      padding: 40px;
      color: #95a5a6;
    }

    @media (max-width: 1200px) {
      .demo-wrapper {
        grid-template-columns: 1fr;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>VCSCI Hexagonal Rating Interface</h1>
    <p class="subtitle">Interfaz de evaluaci칩n biling칲e con sistema de colores por puntaje</p>

    <div class="demo-wrapper">
      <!-- Left: Rating sliders -->
      <div class="ratings-section">
        <h2>Evaluaci칩n por Dimensiones</h2>
        <div id="ratingsContainer"></div>
      </div>

      <!-- Center: Hexagon visualization -->
      <div class="viz-section">
        <h2>Visualizaci칩n Hexagonal</h2>
        <svg id="hexagonChart" width="400" height="400"></svg>
        <div class="vcsci-score">
          <div class="vcsci-score-value" id="vcsciScoreValue">0.00</div>
          <div class="vcsci-score-label">VCSCI Score</div>
        </div>
      </div>

      <!-- Right: Descriptions -->
      <div class="description-section">
        <h2>Descripci칩n del Puntaje</h2>
        <div class="description-content">
          <div id="descriptionDisplay" class="no-selection">
            Mueve los sliders para ver las descripciones de cada puntaje
          </div>
        </div>
      </div>
    </div>

    <!-- Bottom: Compiled evaluation -->
    <div class="compiled-section">
      <h2>Evaluaci칩n Compilada</h2>
      <div class="compiled-evaluation">
        <div id="compiledEvaluation" class="no-selection">
          La evaluaci칩n completa aparecer치 aqu칤 como p치rrafos compilados
        </div>
      </div>

      <div class="export-section">
        <button id="exportBtn" class="export-btn" onclick="exportEvaluation()">
          游닌 Exportar Evaluaci칩n (JSON)
        </button>
        <p class="export-info">
          El JSON incluir치 los p치rrafos completos de la r칰brica para m치xima transparencia
        </p>
      </div>
    </div>
  </div>

  <script>
    // Load rubric descriptions
    let rubricData = null;
    let currentScores = {
      clarity: 3,
      recognizability: 3,
      semantic_transparency: 3,
      pragmatic_fit: 3,
      cultural_adequacy: 3,
      cognitive_accessibility: 3
    };
    let activeDimension = 'clarity';

    const dimensionKeys = [
      'clarity',
      'recognizability',
      'semantic_transparency',
      'pragmatic_fit',
      'cultural_adequacy',
      'cognitive_accessibility'
    ];

    // Load rubric JSON
    async function loadRubric() {
      try {
        const response = await fetch('../data/rubric-scale-descriptions.json');
        rubricData = await response.json();
        console.log('Rubric loaded successfully');
        initializeInterface();
      } catch (error) {
        console.error('Error loading rubric:', error);
        document.getElementById('descriptionDisplay').innerHTML =
          '<div class="loading">Error: No se pudo cargar rubric-scale-descriptions.json</div>';
      }
    }

    function initializeInterface() {
      createRatingSliders();
      drawHexagon();
      updateDescription();
      updateCompiledEvaluation();
    }

    function createRatingSliders() {
      const container = document.getElementById('ratingsContainer');

      dimensionKeys.forEach(key => {
        const dimData = rubricData.dimensions[key];

        const group = document.createElement('div');
        group.className = 'dimension-group';

        const label = document.createElement('label');
        label.className = 'dimension-label';
        label.textContent = dimData.name_es;

        const sliderContainer = document.createElement('div');
        sliderContainer.className = 'slider-container';

        const slider = document.createElement('input');
        slider.type = 'range';
        slider.min = '1';
        slider.max = '5';
        slider.value = currentScores[key];
        slider.className = 'slider';

        const scoreDisplay = document.createElement('span');
        scoreDisplay.className = 'score-display';
        scoreDisplay.textContent = currentScores[key];

        slider.addEventListener('input', (e) => {
          currentScores[key] = parseInt(e.target.value);
          scoreDisplay.textContent = e.target.value;
          activeDimension = key;
          drawHexagon();
          updateDescription();
          updateCompiledEvaluation();
        });

        slider.addEventListener('focus', () => {
          activeDimension = key;
          updateDescription();
        });

        sliderContainer.appendChild(slider);
        sliderContainer.appendChild(scoreDisplay);

        group.appendChild(label);
        group.appendChild(sliderContainer);
        container.appendChild(group);
      });
    }

    function drawHexagon() {
      const svg = document.getElementById('hexagonChart');
      const width = 400;
      const height = 400;
      const centerX = width / 2;
      const centerY = height / 2;
      const maxRadius = 150;

      // Clear SVG
      svg.innerHTML = '';

      // Draw background circles (grid)
      const levels = [1, 2, 3, 4, 5];
      levels.forEach(level => {
        const radius = (level / 5) * maxRadius;
        const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        circle.setAttribute('cx', centerX);
        circle.setAttribute('cy', centerY);
        circle.setAttribute('r', radius);
        circle.setAttribute('fill', 'none');
        circle.setAttribute('stroke', level === 5 ? '#bdc3c7' : '#ecf0f1');
        circle.setAttribute('stroke-width', level === 5 ? '2' : '1');
        circle.setAttribute('stroke-dasharray', level === 5 ? '0' : '5,5');
        svg.appendChild(circle);
      });

      // Draw axes and labels
      dimensionKeys.forEach((key, i) => {
        const dimData = rubricData.dimensions[key];
        const score = currentScores[key];
        const scoreColor = rubricData.scale[score.toString()].color;

        const angle = (Math.PI / 2) - (i * Math.PI / 3);
        const x = centerX + maxRadius * Math.cos(angle);
        const y = centerY - maxRadius * Math.sin(angle);

        // Axis line
        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        line.setAttribute('x1', centerX);
        line.setAttribute('y1', centerY);
        line.setAttribute('x2', x);
        line.setAttribute('y2', y);
        line.setAttribute('stroke', '#d1d8e0');
        line.setAttribute('stroke-width', '1');
        svg.appendChild(line);

        // Label with score-based color
        const labelX = centerX + (maxRadius + 35) * Math.cos(angle);
        const labelY = centerY - (maxRadius + 35) * Math.sin(angle);

        const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        text.setAttribute('x', labelX);
        text.setAttribute('y', labelY);
        text.setAttribute('text-anchor', 'middle');
        text.setAttribute('dominant-baseline', 'middle');
        text.setAttribute('font-size', '11');
        text.setAttribute('font-weight', '600');
        text.setAttribute('fill', scoreColor);
        text.textContent = dimData.name_es;
        svg.appendChild(text);
      });

      // Draw data hexagon
      const points = dimensionKeys.map((key, i) => {
        const score = currentScores[key];
        const radius = (score / 5) * maxRadius;
        const angle = (Math.PI / 2) - (i * Math.PI / 3);
        const x = centerX + radius * Math.cos(angle);
        const y = centerY - radius * Math.sin(angle);
        return `${x},${y}`;
      }).join(' ');

      const polygon = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
      polygon.setAttribute('points', points);
      polygon.setAttribute('fill', 'rgba(102, 126, 234, 0.15)');
      polygon.setAttribute('stroke', '#667eea');
      polygon.setAttribute('stroke-width', '2');
      svg.appendChild(polygon);

      // Draw data points with score-based colors
      dimensionKeys.forEach((key, i) => {
        const score = currentScores[key];
        const scoreColor = rubricData.scale[score.toString()].color;
        const radius = (score / 5) * maxRadius;
        const angle = (Math.PI / 2) - (i * Math.PI / 3);
        const x = centerX + radius * Math.cos(angle);
        const y = centerY - radius * Math.sin(angle);

        const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        circle.setAttribute('cx', x);
        circle.setAttribute('cy', y);
        circle.setAttribute('r', '7');
        circle.setAttribute('fill', scoreColor);
        circle.setAttribute('stroke', 'white');
        circle.setAttribute('stroke-width', '2.5');
        svg.appendChild(circle);
      });

      // Update VCSCI score
      const avgScore = Object.values(currentScores).reduce((a, b) => a + b, 0) / 6;
      document.getElementById('vcsciScoreValue').textContent = avgScore.toFixed(2);
    }

    function updateDescription() {
      if (!rubricData) return;

      const score = currentScores[activeDimension];
      const dimData = rubricData.dimensions[activeDimension];
      const levelData = dimData.levels[score.toString()];
      const scaleData = rubricData.scale[score.toString()];

      const html = `
        <div class="current-dimension">
          <h3>${dimData.name_es}</h3>
          <span class="score-label">Puntaje ${score}/5 - ${scaleData.label_es}</span>
          <div class="dimension-definition">${dimData.description_es}</div>
        </div>
        <div class="description-text">
          ${levelData.text_es}
        </div>
      `;

      document.getElementById('descriptionDisplay').innerHTML = html;
    }

    function updateCompiledEvaluation() {
      if (!rubricData) return;

      const avgScore = Object.values(currentScores).reduce((a, b) => a + b, 0) / 6;
      const roundedScore = Math.round(avgScore);
      const scaleData = rubricData.scale[roundedScore.toString()];

      let html = `
        <div class="overall-summary">
          <strong>VCSCI Score: ${avgScore.toFixed(2)}/5.0 (${scaleData.label_es})</strong>
          <em>${scaleData.general_es}</em>
        </div>
      `;

      dimensionKeys.forEach(key => {
        const score = currentScores[key];
        const dimData = rubricData.dimensions[key];
        const levelData = dimData.levels[score.toString()];
        const scoreColor = rubricData.scale[score.toString()].color;

        html += `
          <div class="evaluation-paragraph" style="border-left-color: ${scoreColor};">
            <strong>${dimData.name_es}:</strong> ${levelData.text_es}
          </div>
        `;
      });

      document.getElementById('compiledEvaluation').innerHTML = html;
    }

    function exportEvaluation() {
      if (!rubricData) {
        alert('Error: Rubric data not loaded');
        return;
      }

      const avgScore = Object.values(currentScores).reduce((a, b) => a + b, 0) / 6;
      const roundedScore = Math.round(avgScore);
      const scaleData = rubricData.scale[roundedScore.toString()];

      // Build dimension evaluations with colors
      const dimensionEvaluations = {};
      const compiledParagraphs = [];

      dimensionKeys.forEach(key => {
        const score = currentScores[key];
        const dimData = rubricData.dimensions[key];
        const levelData = dimData.levels[score.toString()];
        const scaleLevel = rubricData.scale[score.toString()];

        dimensionEvaluations[key] = {
          dimension_name_es: dimData.name_es,
          dimension_name_en: dimData.name_en,
          score: score,
          score_label_es: scaleLevel.label_es,
          score_label_en: scaleLevel.label_en,
          color: scaleLevel.color,
          description_es: levelData.text_es,
          description_en: levelData.text_en
        };

        compiledParagraphs.push({
          dimension: key,
          dimension_label_es: dimData.name_es,
          dimension_label_en: dimData.name_en,
          color: scaleLevel.color,
          text_es: `${dimData.name_es}: ${levelData.text_es}`,
          text_en: `${dimData.name_en}: ${levelData.text_en}`
        });
      });

      // Create complete evaluation object
      const evaluation = {
        metadata: {
          evaluation_date: new Date().toISOString(),
          rubric_version: rubricData.version,
          interface_type: 'hexagonal',
          color_system: 'score-based',
          exported_from: 'hexagonal-rating-with-descriptions.html'
        },
        scores: currentScores,
        vcsci_score: parseFloat(avgScore.toFixed(2)),
        overall_assessment: {
          score: parseFloat(avgScore.toFixed(2)),
          label_es: scaleData.label_es,
          label_en: scaleData.label_en,
          general_description_es: scaleData.general_es,
          general_description_en: scaleData.general_en
        },
        dimension_evaluations: dimensionEvaluations,
        compiled_evaluation: {
          paragraphs: compiledParagraphs,
          full_text_es: compiledParagraphs.map(p => p.text_es).join('\n\n'),
          full_text_en: compiledParagraphs.map(p => p.text_en).join('\n\n'),
          summary_es: `VCSCI Score: ${avgScore.toFixed(2)}/5.0 (${scaleData.label_es}). ${scaleData.general_es}`,
          summary_en: `VCSCI Score: ${avgScore.toFixed(2)}/5.0 (${scaleData.label_en}). ${scaleData.general_en}`
        },
        visualization: {
          color_mapping: 'Colors assigned by score level (1-5), not by dimension',
          score_colors: {
            1: rubricData.scale['1'].color,
            2: rubricData.scale['2'].color,
            3: rubricData.scale['3'].color,
            4: rubricData.scale['4'].color,
            5: rubricData.scale['5'].color
          }
        },
        rubric_transparency: {
          note: 'This evaluation includes complete bilingual rubric descriptions for each score to ensure transparency and reproducibility',
          rubric_source: '../data/rubric-scale-descriptions.json'
        }
      };

      // Download as JSON
      const blob = new Blob([JSON.stringify(evaluation, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `vcsci-evaluation-${new Date().toISOString().split('T')[0]}.json`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);

      console.log('Exported evaluation:', evaluation);
    }

    // Initialize on load
    loadRubric();
  </script>
</body>
</html>
