<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>VCSCI Hexagonal Rating - Gradient Interpolation</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Lexend:wght@300;400;500;600;700&display=swap" rel="stylesheet">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Lexend', sans-serif;
      background: #0a0e27;
      color: #e0e6ed;
      padding: 20px;
      line-height: 1.6;
    }

    .container {
      max-width: 1400px;
      margin: 0 auto;
    }

    h1 {
      text-align: center;
      color: #ffffff;
      margin-bottom: 10px;
      font-weight: 600;
    }

    .subtitle {
      text-align: center;
      color: #8892b0;
      margin-bottom: 30px;
      font-size: 14px;
    }

    .demo-wrapper {
      display: grid;
      grid-template-columns: 400px 1fr 400px;
      gap: 20px;
      margin-bottom: 30px;
    }

    .panel {
      background: rgba(16, 22, 46, 0.8);
      backdrop-filter: blur(10px);
      padding: 25px;
      border-radius: 16px;
      border: 1px solid rgba(100, 255, 218, 0.1);
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
    }

    .panel h2 {
      font-size: 18px;
      color: #64ffda;
      margin-bottom: 20px;
      border-bottom: 2px solid rgba(100, 255, 218, 0.3);
      padding-bottom: 10px;
      font-weight: 600;
    }

    /* Rating sliders */
    .dimension-group {
      margin-bottom: 25px;
    }

    .dimension-label {
      display: flex;
      align-items: center;
      font-weight: 500;
      color: #e0e6ed;
      margin-bottom: 8px;
      font-size: 14px;
    }

    .color-indicator {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      margin-right: 8px;
      box-shadow: 0 0 8px currentColor;
    }

    .slider-container {
      display: flex;
      align-items: center;
      gap: 15px;
    }

    .slider {
      flex: 1;
      height: 8px;
      border-radius: 5px;
      outline: none;
      -webkit-appearance: none;
      background: rgba(255, 255, 255, 0.1);
    }

    .slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 20px;
      height: 20px;
      border-radius: 50%;
      cursor: pointer;
      box-shadow: 0 0 15px currentColor, 0 2px 8px rgba(0,0,0,0.4);
      border: 2px solid rgba(255, 255, 255, 0.3);
    }

    .slider::-moz-range-thumb {
      width: 20px;
      height: 20px;
      border-radius: 50%;
      cursor: pointer;
      border: 2px solid rgba(255, 255, 255, 0.3);
      box-shadow: 0 0 15px currentColor, 0 2px 8px rgba(0,0,0,0.4);
    }

    .score-display {
      min-width: 40px;
      font-weight: 700;
      color: #64ffda;
      font-size: 16px;
      text-align: center;
    }

    /* Canvas container */
    .canvas-container {
      position: relative;
      width: 400px;
      height: 400px;
      margin: 0 auto;
    }

    #hexagonCanvas {
      display: block;
      width: 100%;
      height: 100%;
    }

    /* Description panel */
    .description-content {
      min-height: 400px;
    }

    .current-dimension {
      background: rgba(100, 255, 218, 0.1);
      padding: 15px;
      border-radius: 8px;
      margin-bottom: 20px;
      border-left: 4px solid #64ffda;
    }

    .current-dimension h3 {
      color: #64ffda;
      font-size: 16px;
      margin-bottom: 5px;
      font-weight: 600;
    }

    .current-dimension .score-label {
      color: #8892b0;
      font-size: 14px;
      font-weight: 500;
    }

    .description-text {
      background: rgba(16, 22, 46, 0.6);
      padding: 20px;
      border-radius: 8px;
      border: 1px solid rgba(100, 255, 218, 0.2);
      color: #ccd6f6;
      font-size: 14px;
      line-height: 1.8;
    }

    /* VCSCI Score */
    .vcsci-score {
      text-align: center;
      padding: 25px;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      border-radius: 12px;
      margin-top: 20px;
      box-shadow: 0 4px 20px rgba(102, 126, 234, 0.4);
    }

    .vcsci-score-value {
      font-size: 48px;
      font-weight: 700;
      margin-bottom: 5px;
      text-shadow: 0 2px 10px rgba(0,0,0,0.3);
    }

    .vcsci-score-label {
      font-size: 18px;
      opacity: 0.95;
      font-weight: 500;
    }

    /* Compiled evaluation */
    .compiled-evaluation h3 {
      font-size: 16px;
      color: #64ffda;
      margin-bottom: 15px;
      font-weight: 600;
    }

    .evaluation-paragraph {
      margin-bottom: 15px;
      padding: 12px;
      background: rgba(100, 255, 218, 0.05);
      border-radius: 6px;
      border-left: 3px solid;
      font-size: 13px;
      line-height: 1.6;
    }

    .evaluation-paragraph strong {
      font-weight: 600;
    }

    /* Export button */
    .export-section {
      margin-top: 30px;
      text-align: center;
    }

    .export-btn {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      border: none;
      padding: 15px 40px;
      border-radius: 8px;
      font-size: 16px;
      font-weight: 600;
      font-family: 'Lexend', sans-serif;
      cursor: pointer;
      box-shadow: 0 4px 20px rgba(102, 126, 234, 0.4);
      transition: all 0.3s ease;
    }

    .export-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 25px rgba(102, 126, 234, 0.6);
    }

    .export-info {
      margin-top: 15px;
      font-size: 13px;
      color: #8892b0;
      font-style: italic;
    }

    .no-selection {
      color: #8892b0;
      padding: 60px 20px;
    }

    @media (max-width: 1200px) {
      .demo-wrapper {
        grid-template-columns: 1fr;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>VCSCI Pictogram Evaluation</h1>
    <p class="subtitle">Interpolaci贸n de colores por v茅rtice con Canvas 2D</p>

    <div class="demo-wrapper">
      <!-- Left panel: Rating sliders -->
      <div class="panel">
        <h2>Evaluaci贸n por Dimensiones</h2>
        <div id="ratingsContainer"></div>
      </div>

      <!-- Center panel: Gradient Hexagon -->
      <div class="panel">
        <h2>Visualizaci贸n con Gradientes</h2>
        <div class="canvas-container">
          <canvas id="hexagonCanvas" width="800" height="800"></canvas>
        </div>
        <div class="vcsci-score">
          <div class="vcsci-score-value" id="vcsciScoreValue">0.00</div>
          <div class="vcsci-score-label">VCSCI Score</div>
        </div>
      </div>

      <!-- Right panel: Descriptions -->
      <div class="panel">
        <h2>Descripci贸n del Puntaje</h2>
        <div class="description-content">
          <div id="descriptionDisplay" class="no-selection">
            Mueve los sliders para ver las descripciones
          </div>
        </div>
      </div>
    </div>

    <!-- Bottom panel: Compiled evaluation -->
    <div class="panel">
      <h2>Evaluaci贸n Compilada (Overall)</h2>
      <div class="compiled-evaluation">
        <div id="compiledEvaluation" class="no-selection">
          La evaluaci贸n completa aparecer谩 aqu铆 como p谩rrafos compilados
        </div>
      </div>

      <div class="export-section">
        <button class="export-btn" onclick="exportEvaluation()">
           Exportar Evaluaci贸n (JSON)
        </button>
        <p class="export-info">
          Incluye p谩rrafos completos y metadatos de gradientes
        </p>
      </div>
    </div>
  </div>

  <script>
    // Load rubric descriptions
    let rubricData = null;
    let currentScores = {
      clarity: 3,
      recognizability: 3,
      semantic_transparency: 3,
      pragmatic_fit: 3,
      cultural_adequacy: 3,
      cognitive_accessibility: 3
    };
    let activeDimension = 'clarity';

    // Dimension configuration with unique colors
    const dimensions = [
      { key: 'clarity', label: 'Claridad', color: '#ff6b6b' },                      // Red
      { key: 'semantic_transparency', label: 'Transparencia Sem谩ntica', color: '#ffd93d' }, // Yellow
      { key: 'pragmatic_fit', label: 'Adecuaci贸n Pragm谩tica', color: '#6bcf7f' },   // Green
      { key: 'cultural_adequacy', label: 'Adecuaci贸n Cultural', color: '#4d96ff' }, // Blue
      { key: 'cognitive_accessibility', label: 'Accesibilidad Cognitiva', color: '#9b59b6' }, // Purple
      { key: 'recognizability', label: 'Reconocibilidad', color: '#ff8c42' }        // Orange
    ];

    const canvas = document.getElementById('hexagonCanvas');
    const ctx = canvas.getContext('2d');
    const centerX = 400;
    const centerY = 400;
    const maxRadius = 300;

    // Load rubric JSON
    async function loadRubric() {
      try {
        const response = await fetch('../data/rubric-scale-descriptions.json');
        rubricData = await response.json();
        console.log('Rubric loaded successfully');
        initializeInterface();
      } catch (error) {
        console.error('Error loading rubric:', error);
      }
    }

    function initializeInterface() {
      createRatingSliders();
      drawHexagonWithGradients();
      updateDescription();
      updateCompiledEvaluation();
    }

    function createRatingSliders() {
      const container = document.getElementById('ratingsContainer');

      dimensions.forEach(dim => {
        const group = document.createElement('div');
        group.className = 'dimension-group';

        const label = document.createElement('label');
        label.className = 'dimension-label';

        const colorIndicator = document.createElement('span');
        colorIndicator.className = 'color-indicator';
        colorIndicator.style.background = dim.color;

        label.appendChild(colorIndicator);
        label.appendChild(document.createTextNode(dim.label));

        const sliderContainer = document.createElement('div');
        sliderContainer.className = 'slider-container';

        const slider = document.createElement('input');
        slider.type = 'range';
        slider.min = '1';
        slider.max = '5';
        slider.value = currentScores[dim.key];
        slider.className = 'slider';
        slider.style.setProperty('--thumb-color', dim.color);

        const scoreDisplay = document.createElement('span');
        scoreDisplay.className = 'score-display';
        scoreDisplay.textContent = currentScores[dim.key];

        slider.addEventListener('input', (e) => {
          currentScores[dim.key] = parseInt(e.target.value);
          scoreDisplay.textContent = e.target.value;
          activeDimension = dim.key;
          drawHexagonWithGradients();
          updateDescription();
          updateCompiledEvaluation();
        });

        slider.addEventListener('focus', () => {
          activeDimension = dim.key;
          updateDescription();
        });

        // Apply color to thumb dynamically
        const style = document.createElement('style');
        style.textContent = `
          input[type="range"].slider:nth-of-type(${dimensions.indexOf(dim) + 1})::-webkit-slider-thumb {
            background: ${dim.color};
          }
          input[type="range"].slider:nth-of-type(${dimensions.indexOf(dim) + 1})::-moz-range-thumb {
            background: ${dim.color};
          }
        `;
        document.head.appendChild(style);

        sliderContainer.appendChild(slider);
        sliderContainer.appendChild(scoreDisplay);

        group.appendChild(label);
        group.appendChild(sliderContainer);
        container.appendChild(group);
      });
    }

    function hexagonVertex(index, radius) {
      const angle = (Math.PI / 2) - (index * Math.PI / 3);
      return {
        x: centerX + radius * Math.cos(angle),
        y: centerY - radius * Math.sin(angle)
      };
    }

    function drawHexagonWithGradients() {
      // Clear canvas
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = 'rgba(10, 14, 39, 0.5)';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Draw concentric grid hexagons
      for (let level = 1; level <= 5; level++) {
        const radius = (level / 5) * maxRadius;
        ctx.beginPath();
        for (let i = 0; i <= 6; i++) {
          const vertex = hexagonVertex(i % 6, radius);
          if (i === 0) {
            ctx.moveTo(vertex.x, vertex.y);
          } else {
            ctx.lineTo(vertex.x, vertex.y);
          }
        }
        ctx.closePath();
        ctx.strokeStyle = level === 5 ? 'rgba(100, 255, 218, 0.3)' : 'rgba(100, 255, 218, 0.1)';
        ctx.lineWidth = level === 5 ? 2 : 1;
        ctx.stroke();
      }

      // Draw axes
      dimensions.forEach((dim, i) => {
        const vertex = hexagonVertex(i, maxRadius);
        ctx.beginPath();
        ctx.moveTo(centerX, centerY);
        ctx.lineTo(vertex.x, vertex.y);
        ctx.strokeStyle = 'rgba(136, 146, 176, 0.3)';
        ctx.lineWidth = 1;
        ctx.stroke();

        // Draw dimension labels
        const labelVertex = hexagonVertex(i, maxRadius + 50);
        ctx.save();
        ctx.fillStyle = dim.color;
        ctx.font = '600 14px Lexend';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.shadowColor = dim.color;
        ctx.shadowBlur = 10;
        ctx.fillText(dim.label, labelVertex.x, labelVertex.y);
        ctx.restore();
      });

      // Calculate vertices for current scores
      const vertices = dimensions.map((dim, i) => {
        const score = currentScores[dim.key];
        const radius = (score / 5) * maxRadius;
        return {
          ...hexagonVertex(i, radius),
          color: dim.color,
          score: score
        };
      });

      // Draw gradient-filled hexagon using radial gradients from center
      ctx.save();
      ctx.globalAlpha = 0.7;

      // Create complex gradient effect by drawing triangular segments
      for (let i = 0; i < vertices.length; i++) {
        const v1 = vertices[i];
        const v2 = vertices[(i + 1) % vertices.length];

        // Create gradient from center to edge
        const gradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, maxRadius);
        gradient.addColorStop(0, 'rgba(100, 255, 218, 0.2)');
        gradient.addColorStop(0.5, hexToRgba(v1.color, 0.4));
        gradient.addColorStop(1, hexToRgba(v1.color, 0.6));

        ctx.beginPath();
        ctx.moveTo(centerX, centerY);
        ctx.lineTo(v1.x, v1.y);
        ctx.lineTo(v2.x, v2.y);
        ctx.closePath();
        ctx.fillStyle = gradient;
        ctx.fill();
      }
      ctx.restore();

      // Draw hexagon outline
      ctx.beginPath();
      vertices.forEach((v, i) => {
        if (i === 0) {
          ctx.moveTo(v.x, v.y);
        } else {
          ctx.lineTo(v.x, v.y);
        }
      });
      ctx.closePath();
      ctx.strokeStyle = 'rgba(100, 255, 218, 0.8)';
      ctx.lineWidth = 3;
      ctx.shadowColor = 'rgba(100, 255, 218, 0.6)';
      ctx.shadowBlur = 15;
      ctx.stroke();

      // Draw vertices as colored dots
      vertices.forEach(v => {
        ctx.beginPath();
        ctx.arc(v.x, v.y, 8, 0, Math.PI * 2);
        ctx.fillStyle = v.color;
        ctx.shadowColor = v.color;
        ctx.shadowBlur = 20;
        ctx.fill();
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
        ctx.lineWidth = 2;
        ctx.stroke();
      });

      // Update VCSCI score
      const avgScore = Object.values(currentScores).reduce((a, b) => a + b, 0) / 6;
      document.getElementById('vcsciScoreValue').textContent = avgScore.toFixed(2);
    }

    function hexToRgba(hex, alpha) {
      const r = parseInt(hex.slice(1, 3), 16);
      const g = parseInt(hex.slice(3, 5), 16);
      const b = parseInt(hex.slice(5, 7), 16);
      return `rgba(${r}, ${g}, ${b}, ${alpha})`;
    }

    function updateDescription() {
      if (!rubricData) return;

      const dim = dimensions.find(d => d.key === activeDimension);
      const score = currentScores[activeDimension];
      const dimData = rubricData.dimensions[activeDimension];
      const levelData = dimData.levels[score.toString()];
      const scaleData = rubricData.scale[score.toString()];

      const html = `
        <div class="current-dimension">
          <h3>${dim.label}</h3>
          <p class="score-label">Puntaje ${score}/5 - ${scaleData.label}</p>
        </div>
        <div class="description-text">
          ${levelData.text}
        </div>
      `;

      document.getElementById('descriptionDisplay').innerHTML = html;
    }

    function updateCompiledEvaluation() {
      if (!rubricData) return;

      const avgScore = Object.values(currentScores).reduce((a, b) => a + b, 0) / 6;
      const roundedScore = Math.round(avgScore);
      const scaleData = rubricData.scale[roundedScore.toString()];

      let html = `
        <p style="text-align: center; margin-bottom: 20px; font-size: 16px;">
          <strong>VCSCI Score: ${avgScore.toFixed(2)}/5.0 (${scaleData.label})</strong><br>
          <em>${scaleData.general}</em>
        </p>
      `;

      dimensions.forEach(dim => {
        const score = currentScores[dim.key];
        const dimData = rubricData.dimensions[dim.key];
        const levelData = dimData.levels[score.toString()];

        html += `
          <div class="evaluation-paragraph" style="border-left-color: ${dim.color}">
            <strong>${dim.label}:</strong> ${levelData.text}
          </div>
        `;
      });

      document.getElementById('compiledEvaluation').innerHTML = html;
    }

    function exportEvaluation() {
      if (!rubricData) {
        alert('Error: Rubric data not loaded');
        return;
      }

      const avgScore = Object.values(currentScores).reduce((a, b) => a + b, 0) / 6;
      const roundedScore = Math.round(avgScore);
      const scaleData = rubricData.scale[roundedScore.toString()];

      const compiledParagraphs = [];
      const dimensionEvaluations = {};

      dimensions.forEach(dim => {
        const score = currentScores[dim.key];
        const dimData = rubricData.dimensions[dim.key];
        const levelData = dimData.levels[score.toString()];
        const scaleLevel = rubricData.scale[score.toString()];

        dimensionEvaluations[dim.key] = {
          dimension_name: dim.label,
          dimension_name_en: dimData.name,
          score: score,
          score_label: scaleLevel.label,
          score_label_en: scaleLevel.label_en,
          description: levelData.text,
          description_en: levelData.text_en,
          color: dim.color
        };

        compiledParagraphs.push({
          dimension: dim.key,
          dimension_label: dim.label,
          color: dim.color,
          text: `${dim.label}: ${levelData.text}`
        });
      });

      const evaluation = {
        metadata: {
          evaluation_date: new Date().toISOString(),
          rubric_version: rubricData.version,
          interface_type: 'hexagonal-gradient',
          visualization: 'canvas-2d-gradient-interpolation',
          exported_from: 'hexagonal-rating-gradient.html'
        },
        scores: currentScores,
        vcsci_score: parseFloat(avgScore.toFixed(2)),
        overall_assessment: {
          score: parseFloat(avgScore.toFixed(2)),
          label: scaleData.label,
          label_en: scaleData.label_en,
          general_description: scaleData.general,
          general_description_en: scaleData.general_en
        },
        dimension_evaluations: dimensionEvaluations,
        compiled_evaluation: {
          paragraphs: compiledParagraphs,
          full_text: compiledParagraphs.map(p => p.text).join('\n\n'),
          summary: `VCSCI Score: ${avgScore.toFixed(2)}/5.0 (${scaleData.label}). ${scaleData.general}`
        },
        visualization_metadata: {
          colors: dimensions.map(d => ({ dimension: d.key, color: d.color })),
          gradient_type: 'radial-per-segment',
          note: 'Colors are interpolated using Canvas 2D radial gradients from center'
        },
        rubric_transparency: {
          note: 'This evaluation includes complete rubric descriptions for each score to ensure transparency and reproducibility',
          rubric_source: '../data/rubric-scale-descriptions.json'
        }
      };

      const blob = new Blob([JSON.stringify(evaluation, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `vcsci-evaluation-gradient-${new Date().toISOString().split('T')[0]}.json`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);

      console.log('Exported evaluation with gradient metadata:', evaluation);
    }

    // Initialize
    loadRubric();

    // Animate on load
    let animFrame = 0;
    function animateIn() {
      if (animFrame < 60) {
        animFrame++;
        requestAnimationFrame(animateIn);
        drawHexagonWithGradients();
      }
    }
    setTimeout(animateIn, 500);
  </script>
</body>
</html>
